<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cave_utils.api.maps API documentation</title>
<meta name="description" content="Build out an app bar with buttons to launch pages, launch maps and trigger api commands." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cave_utils.api.maps</code></h1>
</header>
<section id="section-intro">
<p>Build out an app bar with buttons to launch pages, launch maps and trigger api commands.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Build out an app bar with buttons to launch pages, launch maps and trigger api commands.
&#34;&#34;&#34;
from cave_utils.api.utils import ApiValidator, CustomKeyValidator
import type_enforced

@type_enforced.Enforcer
class viewport(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*.defaultViewport
    ## Api Path: maps.data.\*.optionalViewports.\*
    &#34;&#34;&#34;
    @staticmethod
    def spec(latitude: [int, float], longitude: [int, float], zoom: [int, float], bearing: [int, float, None] = None, pitch: [int, float, None] = None, maxZoom: [int, float, None] = None, minZoom: [int, float, None] = None, icon: [str, None] = None, name: [str, None] = None, **kwargs):
        &#34;&#34;&#34;
        Required Arguments:

        - `latitude`:
            - Type: float | int
            - What: The latitude of the viewport.
            - Note: Between -90 and 90.
        - `longitude`:
            - Type: float | int
            - What: The longitude of the viewport.
            - Note: Between -180 and 180.
        - `zoom`:
            - Type: float | int
            - What: The zoom of the viewport.
            - Note: Between 0 and 22.
        - `bearing`:
            - Type: float | int | None
            - What: The bearing of the viewport.
            - Default: `None`
            - Note: Between 0 and 360.
        - `pitch`:
            - Type: float | int | None
            - What: The pitch of the viewport.
            - Default: `None`
            - Note: Between 0 and 60.
        - `maxZoom`:
            - Type: float | int | None
            - What: The maximum zoom of the viewport.
            - Default: `None`
            - Note: Between 0 and 22.
        - `minZoom`:
            - Type: float | int | None
            - What: The minimum zoom of the viewport.
            - Default: `None`
            - Note: Between 0 and 22.
        - `icon`:
            - Type: str | None
            - What: The icon to use for the viewport.
            - Default: `None`
            - Note: If `None`, the default icon will be used.
            - TODO: Check this
        - `name`:
            - Type: str | None
            - What: The name of the viewport.
            - Note: Only used for optional viewports.

        &#34;&#34;&#34;
        return {
            &#34;kwargs&#34;: kwargs,
            &#34;accepted_values&#34;: {},
        }

    def __extend_spec__(self, **kwargs):
        field_validation = {
            &#34;latitude&#34;: (-90, 90),
            &#34;longitude&#34;: (-180, 180),
            &#34;zoom&#34;: (0, 22),
            &#34;bearing&#34;: (0, 360),
            &#34;pitch&#34;: (0, 60),
            &#34;maxZoom&#34;: (0, 22),
            &#34;minZoom&#34;: (0, 22),
        }
        if kwargs.get(&#39;is_optional_viewport&#39;):
            if self.data.get(&#34;name&#34;) is None:
                self.__error__(
                    msg=&#34;`name` must be specified for optional viewports&#34;
                )
            if self.data.get(&#34;icon&#34;) is None:
                self.__error__(
                    msg=&#34;`icon` must be specified for optional viewports&#34;
                )
        for field in [&#34;latitude&#34;, &#34;longitude&#34;, &#34;zoom&#34;, &#34;bearing&#34;, &#34;pitch&#34;, &#34;maxZoom&#34;, &#34;minZoom&#34;]:
            value = self.data.get(field)
            if value is not None:
                if not isinstance(value, (int, float)):
                    continue
                if value &lt; field_validation[field][0] or value &gt; field_validation[field][1]:
                    self.__error__(
                        msg=f&#34;`{field} = {value}` but it should be between {field_validation[field][0]} and {field_validation[field][1]}&#34;
                    )
                    continue
        # TODO: Validate Icons
        # if self.data.get(&#34;icon&#34;) is not None:
        #     self.__check_url_valid__(url=self.data.get(&#34;icon&#34;), prepend_path=[&#34;icon&#34;])

@type_enforced.Enforcer
class colorByOptions(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*.legendGroups.\*.data.\*.colorByOptions
    &#34;&#34;&#34;
    @staticmethod
    def spec(
        startGradientColor: [str, None] = None,
        endGradientColor: [str, None] = None,
        min: [float, int, None] = None,
        max: [float, int, None] = None,
        nullColor: [str, None] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `startGradientColor`:
            - Type: str
            - What: The starting color for the gradient.
            - Accepted Values:
                - Any valid rgba string.
            - Eg: `&#34;rgba(255, 255, 255, 1)&#34;`
            - Note: This is only required for numeric props.
        - `endGradientColor`:
            - Type: str
            - What: The ending color for the gradient.
            - Accepted Values:
                - Any valid rgba string.
            - Eg: `&#34;rgba(255, 255, 255, 1)&#34;`
            - Note: This is only required for numeric props.
        - `customKey`:
            - Type: str
            - What: A color (RGBA String) assigned to a categorical value.
                - Note: You should provide one `customKey` per option key in the associated prop.
            - Note: This is only required for non numeric props.
            - TODO: Flesh this out better

        Optional Arguments:

        - `min`:
            - Type: float | int | None
            - What: The minimum value for calculating the gradient.
            - Default: `None`
            - Note: If None, the min of the relevant data will be used.
        - `max`:
            - Type: float | int | None
            - What: The maximum value for calculating the gradient.
            - Default: `None`
            - Note: If None, the max of the relevant data will be used.
        - `nullColor`:
            - Type: str | None
            - What: The color to use for null values.
            - Default: `None`
            - Note: If None, null values will not be shown
        &#34;&#34;&#34;

        if startGradientColor is not None or endGradientColor is not None:
            if startGradientColor is None:
                raise Exception(&#34;Must provide a `startGradientColor` if `endGradientColor` is provided&#34;)
            if endGradientColor is None:
                raise Exception(&#34;Must provide a `endGradientColor` if `startGradientColor` is provided&#34;)
            return {
                &#34;kwargs&#34;: kwargs,
                &#34;accepted_values&#34;: {},
            }
        else:
            return {
                &#34;kwargs&#34;: {},
                &#34;accepted_values&#34;: {},
            }

    def __extend_spec__(self, **kwargs):
        for field in [&#34;startGradientColor&#34;, &#34;endGradientColor&#34;, &#34;nullColor&#34;]:
            rgba_string = self.data.get(field)
            if rgba_string is not None:
                self.__check_rgba_string_valid__(rgba_string=rgba_string, prepend_path=[field])


@type_enforced.Enforcer
class sizeByOptions(ApiValidator):
    @staticmethod
    def spec(
        startSize: [str, None] = None,
        endSize: [str, None] = None,
        min: [float, int, None] = None,
        max: [float, int, None] = None,
        nullSize: [str, None] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `startSize`:
            - Type: str
            - What: The starting size for the gradient.
            - Accepted Values:
                - Any valid pixel string.
            - Eg: `&#34;10px&#34;`
            - Note: This is only required for numeric props.
        - `endSize`:
            - Type: str
            - What: The ending size for the gradient.
            - Accepted Values:
                - Any valid pixel string.
            - Eg: `&#34;10px&#34;`
            - Note: This is only required for numeric props.
        - `customKey`:
            - Type: str
            - What: A pixel size (pixel String) assigned to a categorical value.
                - Note: You should provide one `customKey` per option key in the associated prop.
            - Note: This is only required for non numeric props.
            - TODO: Flesh this out better

        Optional Arguments:

        - `min`:
            - Type: float | int | None
            - What: The minimum value for calculating the size.
            - Default: `None`
            - Note: If None, the min of the relevant data will be used.
        - `max`:
            - Type: float | int | None
            - What: The maximum value for calculating the size.
            - Default: `None`
            - Note: If None, the max of the relevant data will be used.
        - `nullSize`:
            - Type: str | None
            - What: The size to use for null values.
            - Default: `None`
            - Note: If None, null values will not be shown

        &#34;&#34;&#34;
        if startSize is not None or endSize is not None:
            if startSize is None:
                raise Exception(&#34;Must provide a `startSize` if `endSize` is provided&#34;)
            if endSize is None:
                raise Exception(&#34;Must provide a `endSize` if `startSize` is provided&#34;)
            return {
                &#34;kwargs&#34;: kwargs,
                &#34;accepted_values&#34;: {},
            }
        else:
            return {
                &#34;kwargs&#34;: {},
                &#34;accepted_values&#34;: {},
            }

    def __extend_spec__(self, **kwargs):
        for field in [&#34;startSize&#34;, &#34;endSize&#34;, &#34;nullSize&#34;]:
            field_value = self.data.get(field)
            if field_value is not None:
                self.__check_pixel_string_valid__(pixel_string=field_value, prepend_path=[field])


@type_enforced.Enforcer
class maps_data_star_legendGroups_star_data_star(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*.legendGroups.\*.data.\*
    &#34;&#34;&#34;
    @staticmethod
    def spec(
        value: bool,
        sizeBy: [str, None] = None,
        colorBy: [str, None] = None,
        lineBy: [str, None] = None,
        allowGrouping: bool = False,
        group: [bool, None] = None,
        groupCalcBySize: [str, None] = None,
        groupCalcByColor: [str, None] = None,
        groupScaleWithZoom: bool = False,
        groupScale: [int, float, None] = None,
        colorByOptions: [dict, None] = None,
        sizeByOptions: [dict, None] = None,
        icon: [str, None] = None,
        **kwargs
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `value`:
            - Type: bool
            - What: Whether or not to show this data layer on the map.
        
        Optional Arguments:

        - `sizeBy`:
            - Type: str | None
            - What: The prop to use for sizing the data layer.
            - Default: `None`
            - Note: If `None`, the data layer will not be sized.
            - Note: Does not apply to shape layers.
        - `colorBy`:
            - Type: str | None
            - What: The prop to use for coloring the data layer.
            - Default: `None`
            - Note: If `None`, the data layer will not be colored.
        - `lineBy`:
            - Type: str | None
            - What: The type of line to use for the data layer.
            - Accepted Values: `solid`, `dashed`, `dotted`
            - Default: `solid`
            - Note: Only applies to arc layers
        - `allowGrouping`:
            - Type: bool
            - What: Whether or not to allow grouping of the data layer.
            - Default: `False`
            - Note: Only applies to node layers.
        - `group`:
            - Type: bool | None
            - What: Whether or not to group the data layer.
            - TODO: Validate default value
            - Default: `False`
            - Note: If `None`, the data layer will not be grouped.
            - Note: Only applies to node layers.
        - `groupCalcBySize`:
            - Type: str | None
            - What: The prop to use for calculating the size of the group.
            - Default: `sum`
            - Accepted Values: [`sum`, `mean`, `median`, `mode`, `min`, `max`, `count`, `and`, `or`]
            - Note: If `None`, the data layer will not be grouped.
            - Note: Only applies to node layers.
        - `groupCalcByColor`:
            - Type: str | None
            - What: The prop to use for calculating the color of the group.
            - TODO: Validate default value
            - Default: `sum`
            - Accepted Values: [`sum`, `mean`, `median`, `mode`, `min`, `max`, `count`, `and`, `or`]
            - Note: If `None`, the data layer will not be grouped.
            - Note: Only applies to node layers.
        - `groupScaleWithZoom`:
            - Type: bool
            - What: Whether or not to scale the group size with zoom.
            - Default: `False`
            - Note: Only applies to node layers.
            - Note: If `False`, the group size will be constant as set by `groupScale`.
        - `groupScale`:
            - Type: float | int | None
            - What: The zoom level at which to conduct grouping of the nodes.
            - Default: `None`
            - Note: Only applies to node layers.
            - Note: If `None`, the group scale willl be determined by the map zoom.
        - `colorByOptions`:
            - Type: dict | None
            - What: The options for coloring the data layer.
            - Default: `None`
            - Note: If `None`, the data layer will not be colored.
            - Note: Does not apply to shape layers.
            - TODO: Add numeric and categorical example here.
            - See: `cave_utils.api.maps.colorByOptions`
        - `sizeByOptions`:
            - Type: dict | None
            - What: The options for sizing the data layer.
            - Default: `None`
            - Note: If `None`, the data layer will not be sized.
            - Note: Does not apply to shape layers.
            - TODO: Add numeric and categorical example here.
            - See: `cave_utils.api.maps.sizeByOptions`
        - `icon`:
            - Type: str | None
            - What: The icon to use for the data layer.
            - Note: Only applies to node layers.
            - Note: Arc layer icons are determined by `lineBy`.
            - Note: Shape layer icons are always the default icon.
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {
            # TODO: Validate these are correct accepted values
            &#39;lineBy&#39;: [&#34;solid&#34;, &#34;dashed&#34;, &#34;dotted&#34;],
            &#39;groupCalcBySize&#39;: [&#34;sum&#34;, &#34;mean&#34;, &#34;median&#34;, &#34;mode&#34;, &#34;min&#34;, &#34;max&#34;, &#39;count&#39;, &#39;and&#39;, &#39;or&#39;],
            &#39;groupCalcByColor&#39;: [&#34;sum&#34;, &#34;mean&#34;, &#34;median&#34;, &#34;mode&#34;, &#34;min&#34;, &#34;max&#34;, &#39;count&#39;, &#39;and&#39;, &#39;or&#39;],
        }}
    
    def __extend_spec__(self, **kwargs):
        passed_colorByOptions = self.data.get(&#34;colorByOptions&#34;, {})
        passed_sizeByOptions = self.data.get(&#34;sizeByOptions&#34;, {})
        # TODO: Pass mapFeatures in to validate sizeBy/colorBy/lineBy/groupings
        # TODO: Pass props into colorByOptions and sizeByOptions
        # to validate that option values are valid
        if passed_colorByOptions is not None:
            CustomKeyValidator(
                data = passed_colorByOptions,
                log = self.log,
                prepend_path = [&#34;colorByOptions&#34;],
                validator = colorByOptions,
                **kwargs
            )
        if passed_sizeByOptions is not None:
            CustomKeyValidator(
                data = passed_sizeByOptions,
                log = self.log,
                prepend_path = [&#34;sizeByOptions&#34;],
                validator = sizeByOptions,
                **kwargs
            )
        for by in [&#34;colorBy&#34;, &#34;sizeBy&#34;]:
            by_value = self.data.get(by)
            if by_value is not None:
                available_options = list(self.data.get(f&#34;{by}Options&#34;, {}).keys())
                if by_value not in available_options:
                    self.__error__(
                        msg=f&#34;Invalid `{by}` ({by_value}) must be one of {available_options}&#34;
                    )
        # TODO: Validate Icons


@type_enforced.Enforcer
class maps_data_star_legendGroups_star(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*.legendGroups.\*
    &#34;&#34;&#34;
    @staticmethod
    def spec(
        name: str,
        data: dict,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `name`:   
            - Type: str
            - What: The name of the legend group. This is displayed in the legend menu.
        - `data`:
            - Type: dict
            - What: The relevant data dict for this legend group.
            - See: `cave_utils.api.maps.maps_data_star_legendGroups_star_data_star`    
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {}}

    def __extend_spec__(self, **kwargs):
        CustomKeyValidator(
            data=self.data.get(&#34;data&#34;, {}),
            log=self.log,
            prepend_path=[&#34;data&#34;],
            validator=maps_data_star_legendGroups_star_data_star,
            **kwargs,
        )

@type_enforced.Enforcer
class maps_data_star(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*
    &#34;&#34;&#34;

    @staticmethod
    def spec(
        name: str,
        currentStyle: [str, None] = None,
        currentProjection: [str, None] = None,
        defaultViewport: [dict, None] = None,
        optionalViewports: [dict, None] = None,
        legendGroups: [dict, None] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `name`:
            - Type: str
            - What: The name of the map.
        - `currentStyle`:
            - Type: str
            - What: The id of the style to use when the map is first loaded.
            - Default: `None`
        - `currentProjection`:
            - Type: str
            - What: The id of the projection to use when the map is first loaded.
            - Default: `None`
            - Valid Values: `mercator`, `globe`
        - `defaultViewport`:
            - Type: dict
            - What: The default viewport to use.
            - Default: `None`
            - Note: The value of this field should be a `viewport` object.
            - See: `cave_utils.api.maps.viewport`
        - `optionalViewports`:
            - Type: dict
            - What: The optional viewports that can be selected by the end user.
            - Note: The value of this field should be a dict of `viewport` objects.
            - See: `cave_utils.api.maps.viewport`
        - `legendGroups`:
            - Type: dict
            - What: The legend groups to show in the map selection menu.
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {
            &#34;currentProjection&#34;: [&#34;mercator&#34;, &#34;globe&#34;]
        }}

    def __extend_spec__(self, **kwargs):
        # Validate current style
        current_style = self.data.get(&#34;currentStyle&#34;)
        available_styles = kwargs.get(&#34;available_styles&#34;, [])
        if current_style is not None and current_style not in available_styles:
            self.__error__(
                msg=f&#34;Invalid `currentStyle` ({current_style}) must be one of {available_styles}&#34;
            )
        # Validate the default viewport
        viewport(
            data=self.data.get(&#34;defaultViewport&#34;, {}),
            log=self.log,
            prepend_path=[&#34;defaultViewport&#34;],
            is_optional_viewport=False,
        )
        # Validate the optional viewports
        CustomKeyValidator(
            data=self.data.get(&#34;optionalViewports&#34;, {}),
            log=self.log,
            prepend_path=[&#34;optionalViewports&#34;],
            validator=viewport,
            is_optional_viewport=True,
        )
        # Validate legend groups
        CustomKeyValidator(
            data=self.data.get(&#34;legendGroups&#34;, {}),
            log=self.log,
            prepend_path=[&#34;legendGroups&#34;],
            validator=maps_data_star_legendGroups_star,
            **kwargs,
        )


@type_enforced.Enforcer
class maps_additionalMapStyles_star(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.additionalMapStyles.\*
    &#34;&#34;&#34;

    @staticmethod
    def spec(name: str, icon: str, spec: [dict, str], fog: [dict, None] = None, **kwargs):
        &#34;&#34;&#34;
        Required Arguments:

        - `name`:
            - Type: str
            - What: The name of the style.
        - `icon`:
            - Type: str
            - What: The icon to show in the map selection menu.
        - `spec`:
            - Type: dict | str
            - What: The spec to generate the map
            - See: Mapbox: https://docs.mapbox.com/api/maps/styles/
            - See: Carto: https://github.com/CartoDB/basemap-styles/blob/master/docs/basemap_styles.json
            - See: Raster: https://docs.mapbox.com/mapbox-gl-js/example/map-tiles/
            - Note: `spec` can be a dict or a string. If it is a string, it will be treated as a url to a json file.
            - Note: `spec` is not validated except that it should be a dict or a string.

        Optional Arguments:

        - `fog`:
            - Type: dict
            - What: The fog to show in the map selection menu.
            - Note: Fog is not validated except that it should be a dict.
            - See: https://docs.mapbox.com/mapbox-gl-js/api/map/#map#setfog
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {}}

    def __extend_spec__(self, **kwargs):
        pass
        # TODO: Validate icon
        # TODO: Possibly validate spec and fog


@type_enforced.Enforcer
class maps(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps
    &#34;&#34;&#34;

    @staticmethod
    def spec(additionalMapStyles: dict = dict(), data: dict = dict(), **kwargs):
        &#34;&#34;&#34;
        Optional Arguments:

        - `data`:
            - Type: dict
            - What: The data to pass to `maps.data.*`.
            - Default: `{}`
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {}}

    def __extend_spec__(self, **kwargs):
        data = self.data.get(&#34;data&#34;, {})
        CustomKeyValidator(
            data=self.data.get(&#34;additionalMapStyles&#34;, {}),
            log=self.log,
            prepend_path=[&#34;additionalMapStyles&#34;],
            validator=maps_additionalMapStyles_star,
            **kwargs,
        )
        available_styles = list(self.data.get(&#34;additionalMapStyles&#34;, {}).keys()) + [&#34;default&#34;, &#34;dark&#34;, &#34;light&#34;]
        CustomKeyValidator(
            data=data, 
            log=self.log, 
            prepend_path=[&#34;data&#34;], 
            validator=maps_data_star,
            available_styles=available_styles,
            **kwargs
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cave_utils.api.maps.colorByOptions"><code class="flex name class">
<span>class <span class="ident">colorByOptions</span></span>
<span>(</span><span>**fields)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api-path-mapsdatalegendgroupsdatacolorbyoptions">Api Path: maps.data.*.legendGroups.*.data.*.colorByOptions</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@type_enforced.Enforcer
class colorByOptions(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*.legendGroups.\*.data.\*.colorByOptions
    &#34;&#34;&#34;
    @staticmethod
    def spec(
        startGradientColor: [str, None] = None,
        endGradientColor: [str, None] = None,
        min: [float, int, None] = None,
        max: [float, int, None] = None,
        nullColor: [str, None] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `startGradientColor`:
            - Type: str
            - What: The starting color for the gradient.
            - Accepted Values:
                - Any valid rgba string.
            - Eg: `&#34;rgba(255, 255, 255, 1)&#34;`
            - Note: This is only required for numeric props.
        - `endGradientColor`:
            - Type: str
            - What: The ending color for the gradient.
            - Accepted Values:
                - Any valid rgba string.
            - Eg: `&#34;rgba(255, 255, 255, 1)&#34;`
            - Note: This is only required for numeric props.
        - `customKey`:
            - Type: str
            - What: A color (RGBA String) assigned to a categorical value.
                - Note: You should provide one `customKey` per option key in the associated prop.
            - Note: This is only required for non numeric props.
            - TODO: Flesh this out better

        Optional Arguments:

        - `min`:
            - Type: float | int | None
            - What: The minimum value for calculating the gradient.
            - Default: `None`
            - Note: If None, the min of the relevant data will be used.
        - `max`:
            - Type: float | int | None
            - What: The maximum value for calculating the gradient.
            - Default: `None`
            - Note: If None, the max of the relevant data will be used.
        - `nullColor`:
            - Type: str | None
            - What: The color to use for null values.
            - Default: `None`
            - Note: If None, null values will not be shown
        &#34;&#34;&#34;

        if startGradientColor is not None or endGradientColor is not None:
            if startGradientColor is None:
                raise Exception(&#34;Must provide a `startGradientColor` if `endGradientColor` is provided&#34;)
            if endGradientColor is None:
                raise Exception(&#34;Must provide a `endGradientColor` if `startGradientColor` is provided&#34;)
            return {
                &#34;kwargs&#34;: kwargs,
                &#34;accepted_values&#34;: {},
            }
        else:
            return {
                &#34;kwargs&#34;: {},
                &#34;accepted_values&#34;: {},
            }

    def __extend_spec__(self, **kwargs):
        for field in [&#34;startGradientColor&#34;, &#34;endGradientColor&#34;, &#34;nullColor&#34;]:
            rgba_string = self.data.get(field)
            if rgba_string is not None:
                self.__check_rgba_string_valid__(rgba_string=rgba_string, prepend_path=[field])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cave_utils.api.utils.ApiValidator" href="utils.html#cave_utils.api.utils.ApiValidator">ApiValidator</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cave_utils.api.maps.colorByOptions.spec"><code class="name flex">
<span>def <span class="ident">spec</span></span>(<span>startGradientColor: [<class 'str'>, None] = None, endGradientColor: [<class 'str'>, None] = None, min: [<class 'float'>, <class 'int'>, None] = None, max: [<class 'float'>, <class 'int'>, None] = None, nullColor: [<class 'str'>, None] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Required Arguments:</p>
<ul>
<li><code>startGradientColor</code>:<ul>
<li>Type: str</li>
<li>What: The starting color for the gradient.</li>
<li>Accepted Values:<ul>
<li>Any valid rgba string.</li>
</ul>
</li>
<li>Eg: <code>"rgba(255, 255, 255, 1)"</code></li>
<li>Note: This is only required for numeric props.</li>
</ul>
</li>
<li><code>endGradientColor</code>:<ul>
<li>Type: str</li>
<li>What: The ending color for the gradient.</li>
<li>Accepted Values:<ul>
<li>Any valid rgba string.</li>
</ul>
</li>
<li>Eg: <code>"rgba(255, 255, 255, 1)"</code></li>
<li>Note: This is only required for numeric props.</li>
</ul>
</li>
<li><code>customKey</code>:<ul>
<li>Type: str</li>
<li>What: A color (RGBA String) assigned to a categorical value.<ul>
<li>Note: You should provide one <code>customKey</code> per option key in the associated prop.</li>
</ul>
</li>
<li>Note: This is only required for non numeric props.</li>
<li>TODO: Flesh this out better</li>
</ul>
</li>
</ul>
<p>Optional Arguments:</p>
<ul>
<li><code>min</code>:<ul>
<li>Type: float | int | None</li>
<li>What: The minimum value for calculating the gradient.</li>
<li>Default: <code>None</code></li>
<li>Note: If None, the min of the relevant data will be used.</li>
</ul>
</li>
<li><code>max</code>:<ul>
<li>Type: float | int | None</li>
<li>What: The maximum value for calculating the gradient.</li>
<li>Default: <code>None</code></li>
<li>Note: If None, the max of the relevant data will be used.</li>
</ul>
</li>
<li><code>nullColor</code>:<ul>
<li>Type: str | None</li>
<li>What: The color to use for null values.</li>
<li>Default: <code>None</code></li>
<li>Note: If None, null values will not be shown</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spec(
    startGradientColor: [str, None] = None,
    endGradientColor: [str, None] = None,
    min: [float, int, None] = None,
    max: [float, int, None] = None,
    nullColor: [str, None] = None,
    **kwargs,
):
    &#34;&#34;&#34;
    Required Arguments:

    - `startGradientColor`:
        - Type: str
        - What: The starting color for the gradient.
        - Accepted Values:
            - Any valid rgba string.
        - Eg: `&#34;rgba(255, 255, 255, 1)&#34;`
        - Note: This is only required for numeric props.
    - `endGradientColor`:
        - Type: str
        - What: The ending color for the gradient.
        - Accepted Values:
            - Any valid rgba string.
        - Eg: `&#34;rgba(255, 255, 255, 1)&#34;`
        - Note: This is only required for numeric props.
    - `customKey`:
        - Type: str
        - What: A color (RGBA String) assigned to a categorical value.
            - Note: You should provide one `customKey` per option key in the associated prop.
        - Note: This is only required for non numeric props.
        - TODO: Flesh this out better

    Optional Arguments:

    - `min`:
        - Type: float | int | None
        - What: The minimum value for calculating the gradient.
        - Default: `None`
        - Note: If None, the min of the relevant data will be used.
    - `max`:
        - Type: float | int | None
        - What: The maximum value for calculating the gradient.
        - Default: `None`
        - Note: If None, the max of the relevant data will be used.
    - `nullColor`:
        - Type: str | None
        - What: The color to use for null values.
        - Default: `None`
        - Note: If None, null values will not be shown
    &#34;&#34;&#34;

    if startGradientColor is not None or endGradientColor is not None:
        if startGradientColor is None:
            raise Exception(&#34;Must provide a `startGradientColor` if `endGradientColor` is provided&#34;)
        if endGradientColor is None:
            raise Exception(&#34;Must provide a `endGradientColor` if `startGradientColor` is provided&#34;)
        return {
            &#34;kwargs&#34;: kwargs,
            &#34;accepted_values&#34;: {},
        }
    else:
        return {
            &#34;kwargs&#34;: {},
            &#34;accepted_values&#34;: {},
        }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cave_utils.api.maps.maps"><code class="flex name class">
<span>class <span class="ident">maps</span></span>
<span>(</span><span>**fields)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api-path-maps">Api Path: maps</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@type_enforced.Enforcer
class maps(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps
    &#34;&#34;&#34;

    @staticmethod
    def spec(additionalMapStyles: dict = dict(), data: dict = dict(), **kwargs):
        &#34;&#34;&#34;
        Optional Arguments:

        - `data`:
            - Type: dict
            - What: The data to pass to `maps.data.*`.
            - Default: `{}`
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {}}

    def __extend_spec__(self, **kwargs):
        data = self.data.get(&#34;data&#34;, {})
        CustomKeyValidator(
            data=self.data.get(&#34;additionalMapStyles&#34;, {}),
            log=self.log,
            prepend_path=[&#34;additionalMapStyles&#34;],
            validator=maps_additionalMapStyles_star,
            **kwargs,
        )
        available_styles = list(self.data.get(&#34;additionalMapStyles&#34;, {}).keys()) + [&#34;default&#34;, &#34;dark&#34;, &#34;light&#34;]
        CustomKeyValidator(
            data=data, 
            log=self.log, 
            prepend_path=[&#34;data&#34;], 
            validator=maps_data_star,
            available_styles=available_styles,
            **kwargs
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cave_utils.api.utils.ApiValidator" href="utils.html#cave_utils.api.utils.ApiValidator">ApiValidator</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cave_utils.api.maps.maps.spec"><code class="name flex">
<span>def <span class="ident">spec</span></span>(<span>additionalMapStyles: dict = {}, data: dict = {}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Optional Arguments:</p>
<ul>
<li><code>data</code>:<ul>
<li>Type: dict</li>
<li>What: The data to pass to <code>maps.data.*</code>.</li>
<li>Default: <code>{}</code></li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spec(additionalMapStyles: dict = dict(), data: dict = dict(), **kwargs):
    &#34;&#34;&#34;
    Optional Arguments:

    - `data`:
        - Type: dict
        - What: The data to pass to `maps.data.*`.
        - Default: `{}`
    &#34;&#34;&#34;
    return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {}}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cave_utils.api.maps.maps_additionalMapStyles_star"><code class="flex name class">
<span>class <span class="ident">maps_additionalMapStyles_star</span></span>
<span>(</span><span>**fields)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api-path-mapsadditionalmapstyles">Api Path: maps.additionalMapStyles.*</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@type_enforced.Enforcer
class maps_additionalMapStyles_star(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.additionalMapStyles.\*
    &#34;&#34;&#34;

    @staticmethod
    def spec(name: str, icon: str, spec: [dict, str], fog: [dict, None] = None, **kwargs):
        &#34;&#34;&#34;
        Required Arguments:

        - `name`:
            - Type: str
            - What: The name of the style.
        - `icon`:
            - Type: str
            - What: The icon to show in the map selection menu.
        - `spec`:
            - Type: dict | str
            - What: The spec to generate the map
            - See: Mapbox: https://docs.mapbox.com/api/maps/styles/
            - See: Carto: https://github.com/CartoDB/basemap-styles/blob/master/docs/basemap_styles.json
            - See: Raster: https://docs.mapbox.com/mapbox-gl-js/example/map-tiles/
            - Note: `spec` can be a dict or a string. If it is a string, it will be treated as a url to a json file.
            - Note: `spec` is not validated except that it should be a dict or a string.

        Optional Arguments:

        - `fog`:
            - Type: dict
            - What: The fog to show in the map selection menu.
            - Note: Fog is not validated except that it should be a dict.
            - See: https://docs.mapbox.com/mapbox-gl-js/api/map/#map#setfog
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {}}

    def __extend_spec__(self, **kwargs):
        pass
        # TODO: Validate icon
        # TODO: Possibly validate spec and fog</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cave_utils.api.utils.ApiValidator" href="utils.html#cave_utils.api.utils.ApiValidator">ApiValidator</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cave_utils.api.maps.maps_additionalMapStyles_star.spec"><code class="name flex">
<span>def <span class="ident">spec</span></span>(<span>name: str, icon: str, spec: [<class 'dict'>, <class 'str'>], fog: [<class 'dict'>, None] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Required Arguments:</p>
<ul>
<li><code>name</code>:<ul>
<li>Type: str</li>
<li>What: The name of the style.</li>
</ul>
</li>
<li><code>icon</code>:<ul>
<li>Type: str</li>
<li>What: The icon to show in the map selection menu.</li>
</ul>
</li>
<li><code>spec</code>:<ul>
<li>Type: dict | str</li>
<li>What: The spec to generate the map</li>
<li>See: Mapbox: <a href="https://docs.mapbox.com/api/maps/styles/">https://docs.mapbox.com/api/maps/styles/</a></li>
<li>See: Carto: <a href="https://github.com/CartoDB/basemap-styles/blob/master/docs/basemap_styles.json">https://github.com/CartoDB/basemap-styles/blob/master/docs/basemap_styles.json</a></li>
<li>See: Raster: <a href="https://docs.mapbox.com/mapbox-gl-js/example/map-tiles/">https://docs.mapbox.com/mapbox-gl-js/example/map-tiles/</a></li>
<li>Note: <code>spec</code> can be a dict or a string. If it is a string, it will be treated as a url to a json file.</li>
<li>Note: <code>spec</code> is not validated except that it should be a dict or a string.</li>
</ul>
</li>
</ul>
<p>Optional Arguments:</p>
<ul>
<li><code>fog</code>:<ul>
<li>Type: dict</li>
<li>What: The fog to show in the map selection menu.</li>
<li>Note: Fog is not validated except that it should be a dict.</li>
<li>See: <a href="https://docs.mapbox.com/mapbox-gl-js/api/map/#map#setfog">https://docs.mapbox.com/mapbox-gl-js/api/map/#map#setfog</a></li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spec(name: str, icon: str, spec: [dict, str], fog: [dict, None] = None, **kwargs):
    &#34;&#34;&#34;
    Required Arguments:

    - `name`:
        - Type: str
        - What: The name of the style.
    - `icon`:
        - Type: str
        - What: The icon to show in the map selection menu.
    - `spec`:
        - Type: dict | str
        - What: The spec to generate the map
        - See: Mapbox: https://docs.mapbox.com/api/maps/styles/
        - See: Carto: https://github.com/CartoDB/basemap-styles/blob/master/docs/basemap_styles.json
        - See: Raster: https://docs.mapbox.com/mapbox-gl-js/example/map-tiles/
        - Note: `spec` can be a dict or a string. If it is a string, it will be treated as a url to a json file.
        - Note: `spec` is not validated except that it should be a dict or a string.

    Optional Arguments:

    - `fog`:
        - Type: dict
        - What: The fog to show in the map selection menu.
        - Note: Fog is not validated except that it should be a dict.
        - See: https://docs.mapbox.com/mapbox-gl-js/api/map/#map#setfog
    &#34;&#34;&#34;
    return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {}}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cave_utils.api.maps.maps_data_star"><code class="flex name class">
<span>class <span class="ident">maps_data_star</span></span>
<span>(</span><span>**fields)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api-path-mapsdata">Api Path: maps.data.*</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@type_enforced.Enforcer
class maps_data_star(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*
    &#34;&#34;&#34;

    @staticmethod
    def spec(
        name: str,
        currentStyle: [str, None] = None,
        currentProjection: [str, None] = None,
        defaultViewport: [dict, None] = None,
        optionalViewports: [dict, None] = None,
        legendGroups: [dict, None] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `name`:
            - Type: str
            - What: The name of the map.
        - `currentStyle`:
            - Type: str
            - What: The id of the style to use when the map is first loaded.
            - Default: `None`
        - `currentProjection`:
            - Type: str
            - What: The id of the projection to use when the map is first loaded.
            - Default: `None`
            - Valid Values: `mercator`, `globe`
        - `defaultViewport`:
            - Type: dict
            - What: The default viewport to use.
            - Default: `None`
            - Note: The value of this field should be a `viewport` object.
            - See: `cave_utils.api.maps.viewport`
        - `optionalViewports`:
            - Type: dict
            - What: The optional viewports that can be selected by the end user.
            - Note: The value of this field should be a dict of `viewport` objects.
            - See: `cave_utils.api.maps.viewport`
        - `legendGroups`:
            - Type: dict
            - What: The legend groups to show in the map selection menu.
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {
            &#34;currentProjection&#34;: [&#34;mercator&#34;, &#34;globe&#34;]
        }}

    def __extend_spec__(self, **kwargs):
        # Validate current style
        current_style = self.data.get(&#34;currentStyle&#34;)
        available_styles = kwargs.get(&#34;available_styles&#34;, [])
        if current_style is not None and current_style not in available_styles:
            self.__error__(
                msg=f&#34;Invalid `currentStyle` ({current_style}) must be one of {available_styles}&#34;
            )
        # Validate the default viewport
        viewport(
            data=self.data.get(&#34;defaultViewport&#34;, {}),
            log=self.log,
            prepend_path=[&#34;defaultViewport&#34;],
            is_optional_viewport=False,
        )
        # Validate the optional viewports
        CustomKeyValidator(
            data=self.data.get(&#34;optionalViewports&#34;, {}),
            log=self.log,
            prepend_path=[&#34;optionalViewports&#34;],
            validator=viewport,
            is_optional_viewport=True,
        )
        # Validate legend groups
        CustomKeyValidator(
            data=self.data.get(&#34;legendGroups&#34;, {}),
            log=self.log,
            prepend_path=[&#34;legendGroups&#34;],
            validator=maps_data_star_legendGroups_star,
            **kwargs,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cave_utils.api.utils.ApiValidator" href="utils.html#cave_utils.api.utils.ApiValidator">ApiValidator</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cave_utils.api.maps.maps_data_star.spec"><code class="name flex">
<span>def <span class="ident">spec</span></span>(<span>name: str, currentStyle: [<class 'str'>, None] = None, currentProjection: [<class 'str'>, None] = None, defaultViewport: [<class 'dict'>, None] = None, optionalViewports: [<class 'dict'>, None] = None, legendGroups: [<class 'dict'>, None] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Required Arguments:</p>
<ul>
<li><code>name</code>:<ul>
<li>Type: str</li>
<li>What: The name of the map.</li>
</ul>
</li>
<li><code>currentStyle</code>:<ul>
<li>Type: str</li>
<li>What: The id of the style to use when the map is first loaded.</li>
<li>Default: <code>None</code></li>
</ul>
</li>
<li><code>currentProjection</code>:<ul>
<li>Type: str</li>
<li>What: The id of the projection to use when the map is first loaded.</li>
<li>Default: <code>None</code></li>
<li>Valid Values: <code>mercator</code>, <code>globe</code></li>
</ul>
</li>
<li><code>defaultViewport</code>:<ul>
<li>Type: dict</li>
<li>What: The default viewport to use.</li>
<li>Default: <code>None</code></li>
<li>Note: The value of this field should be a <code><a title="cave_utils.api.maps.viewport" href="#cave_utils.api.maps.viewport">viewport</a></code> object.</li>
<li>See: <code><a title="cave_utils.api.maps.viewport" href="#cave_utils.api.maps.viewport">viewport</a></code></li>
</ul>
</li>
<li><code>optionalViewports</code>:<ul>
<li>Type: dict</li>
<li>What: The optional viewports that can be selected by the end user.</li>
<li>Note: The value of this field should be a dict of <code><a title="cave_utils.api.maps.viewport" href="#cave_utils.api.maps.viewport">viewport</a></code> objects.</li>
<li>See: <code><a title="cave_utils.api.maps.viewport" href="#cave_utils.api.maps.viewport">viewport</a></code></li>
</ul>
</li>
<li><code>legendGroups</code>:<ul>
<li>Type: dict</li>
<li>What: The legend groups to show in the map selection menu.</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spec(
    name: str,
    currentStyle: [str, None] = None,
    currentProjection: [str, None] = None,
    defaultViewport: [dict, None] = None,
    optionalViewports: [dict, None] = None,
    legendGroups: [dict, None] = None,
    **kwargs,
):
    &#34;&#34;&#34;
    Required Arguments:

    - `name`:
        - Type: str
        - What: The name of the map.
    - `currentStyle`:
        - Type: str
        - What: The id of the style to use when the map is first loaded.
        - Default: `None`
    - `currentProjection`:
        - Type: str
        - What: The id of the projection to use when the map is first loaded.
        - Default: `None`
        - Valid Values: `mercator`, `globe`
    - `defaultViewport`:
        - Type: dict
        - What: The default viewport to use.
        - Default: `None`
        - Note: The value of this field should be a `viewport` object.
        - See: `cave_utils.api.maps.viewport`
    - `optionalViewports`:
        - Type: dict
        - What: The optional viewports that can be selected by the end user.
        - Note: The value of this field should be a dict of `viewport` objects.
        - See: `cave_utils.api.maps.viewport`
    - `legendGroups`:
        - Type: dict
        - What: The legend groups to show in the map selection menu.
    &#34;&#34;&#34;
    return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {
        &#34;currentProjection&#34;: [&#34;mercator&#34;, &#34;globe&#34;]
    }}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cave_utils.api.maps.maps_data_star_legendGroups_star"><code class="flex name class">
<span>class <span class="ident">maps_data_star_legendGroups_star</span></span>
<span>(</span><span>**fields)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api-path-mapsdatalegendgroups">Api Path: maps.data.*.legendGroups.*</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@type_enforced.Enforcer
class maps_data_star_legendGroups_star(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*.legendGroups.\*
    &#34;&#34;&#34;
    @staticmethod
    def spec(
        name: str,
        data: dict,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `name`:   
            - Type: str
            - What: The name of the legend group. This is displayed in the legend menu.
        - `data`:
            - Type: dict
            - What: The relevant data dict for this legend group.
            - See: `cave_utils.api.maps.maps_data_star_legendGroups_star_data_star`    
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {}}

    def __extend_spec__(self, **kwargs):
        CustomKeyValidator(
            data=self.data.get(&#34;data&#34;, {}),
            log=self.log,
            prepend_path=[&#34;data&#34;],
            validator=maps_data_star_legendGroups_star_data_star,
            **kwargs,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cave_utils.api.utils.ApiValidator" href="utils.html#cave_utils.api.utils.ApiValidator">ApiValidator</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cave_utils.api.maps.maps_data_star_legendGroups_star.spec"><code class="name flex">
<span>def <span class="ident">spec</span></span>(<span>name: str, data: dict, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Required Arguments:</p>
<ul>
<li><code>name</code>:
<ul>
<li>Type: str</li>
<li>What: The name of the legend group. This is displayed in the legend menu.</li>
</ul>
</li>
<li><code>data</code>:<ul>
<li>Type: dict</li>
<li>What: The relevant data dict for this legend group.</li>
<li>See: <code><a title="cave_utils.api.maps.maps_data_star_legendGroups_star_data_star" href="#cave_utils.api.maps.maps_data_star_legendGroups_star_data_star">maps_data_star_legendGroups_star_data_star</a></code></li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spec(
    name: str,
    data: dict,
    **kwargs,
):
    &#34;&#34;&#34;
    Required Arguments:

    - `name`:   
        - Type: str
        - What: The name of the legend group. This is displayed in the legend menu.
    - `data`:
        - Type: dict
        - What: The relevant data dict for this legend group.
        - See: `cave_utils.api.maps.maps_data_star_legendGroups_star_data_star`    
    &#34;&#34;&#34;
    return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {}}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cave_utils.api.maps.maps_data_star_legendGroups_star_data_star"><code class="flex name class">
<span>class <span class="ident">maps_data_star_legendGroups_star_data_star</span></span>
<span>(</span><span>**fields)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api-path-mapsdatalegendgroupsdata">Api Path: maps.data.*.legendGroups.*.data.*</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@type_enforced.Enforcer
class maps_data_star_legendGroups_star_data_star(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*.legendGroups.\*.data.\*
    &#34;&#34;&#34;
    @staticmethod
    def spec(
        value: bool,
        sizeBy: [str, None] = None,
        colorBy: [str, None] = None,
        lineBy: [str, None] = None,
        allowGrouping: bool = False,
        group: [bool, None] = None,
        groupCalcBySize: [str, None] = None,
        groupCalcByColor: [str, None] = None,
        groupScaleWithZoom: bool = False,
        groupScale: [int, float, None] = None,
        colorByOptions: [dict, None] = None,
        sizeByOptions: [dict, None] = None,
        icon: [str, None] = None,
        **kwargs
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `value`:
            - Type: bool
            - What: Whether or not to show this data layer on the map.
        
        Optional Arguments:

        - `sizeBy`:
            - Type: str | None
            - What: The prop to use for sizing the data layer.
            - Default: `None`
            - Note: If `None`, the data layer will not be sized.
            - Note: Does not apply to shape layers.
        - `colorBy`:
            - Type: str | None
            - What: The prop to use for coloring the data layer.
            - Default: `None`
            - Note: If `None`, the data layer will not be colored.
        - `lineBy`:
            - Type: str | None
            - What: The type of line to use for the data layer.
            - Accepted Values: `solid`, `dashed`, `dotted`
            - Default: `solid`
            - Note: Only applies to arc layers
        - `allowGrouping`:
            - Type: bool
            - What: Whether or not to allow grouping of the data layer.
            - Default: `False`
            - Note: Only applies to node layers.
        - `group`:
            - Type: bool | None
            - What: Whether or not to group the data layer.
            - TODO: Validate default value
            - Default: `False`
            - Note: If `None`, the data layer will not be grouped.
            - Note: Only applies to node layers.
        - `groupCalcBySize`:
            - Type: str | None
            - What: The prop to use for calculating the size of the group.
            - Default: `sum`
            - Accepted Values: [`sum`, `mean`, `median`, `mode`, `min`, `max`, `count`, `and`, `or`]
            - Note: If `None`, the data layer will not be grouped.
            - Note: Only applies to node layers.
        - `groupCalcByColor`:
            - Type: str | None
            - What: The prop to use for calculating the color of the group.
            - TODO: Validate default value
            - Default: `sum`
            - Accepted Values: [`sum`, `mean`, `median`, `mode`, `min`, `max`, `count`, `and`, `or`]
            - Note: If `None`, the data layer will not be grouped.
            - Note: Only applies to node layers.
        - `groupScaleWithZoom`:
            - Type: bool
            - What: Whether or not to scale the group size with zoom.
            - Default: `False`
            - Note: Only applies to node layers.
            - Note: If `False`, the group size will be constant as set by `groupScale`.
        - `groupScale`:
            - Type: float | int | None
            - What: The zoom level at which to conduct grouping of the nodes.
            - Default: `None`
            - Note: Only applies to node layers.
            - Note: If `None`, the group scale willl be determined by the map zoom.
        - `colorByOptions`:
            - Type: dict | None
            - What: The options for coloring the data layer.
            - Default: `None`
            - Note: If `None`, the data layer will not be colored.
            - Note: Does not apply to shape layers.
            - TODO: Add numeric and categorical example here.
            - See: `cave_utils.api.maps.colorByOptions`
        - `sizeByOptions`:
            - Type: dict | None
            - What: The options for sizing the data layer.
            - Default: `None`
            - Note: If `None`, the data layer will not be sized.
            - Note: Does not apply to shape layers.
            - TODO: Add numeric and categorical example here.
            - See: `cave_utils.api.maps.sizeByOptions`
        - `icon`:
            - Type: str | None
            - What: The icon to use for the data layer.
            - Note: Only applies to node layers.
            - Note: Arc layer icons are determined by `lineBy`.
            - Note: Shape layer icons are always the default icon.
        &#34;&#34;&#34;
        return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {
            # TODO: Validate these are correct accepted values
            &#39;lineBy&#39;: [&#34;solid&#34;, &#34;dashed&#34;, &#34;dotted&#34;],
            &#39;groupCalcBySize&#39;: [&#34;sum&#34;, &#34;mean&#34;, &#34;median&#34;, &#34;mode&#34;, &#34;min&#34;, &#34;max&#34;, &#39;count&#39;, &#39;and&#39;, &#39;or&#39;],
            &#39;groupCalcByColor&#39;: [&#34;sum&#34;, &#34;mean&#34;, &#34;median&#34;, &#34;mode&#34;, &#34;min&#34;, &#34;max&#34;, &#39;count&#39;, &#39;and&#39;, &#39;or&#39;],
        }}
    
    def __extend_spec__(self, **kwargs):
        passed_colorByOptions = self.data.get(&#34;colorByOptions&#34;, {})
        passed_sizeByOptions = self.data.get(&#34;sizeByOptions&#34;, {})
        # TODO: Pass mapFeatures in to validate sizeBy/colorBy/lineBy/groupings
        # TODO: Pass props into colorByOptions and sizeByOptions
        # to validate that option values are valid
        if passed_colorByOptions is not None:
            CustomKeyValidator(
                data = passed_colorByOptions,
                log = self.log,
                prepend_path = [&#34;colorByOptions&#34;],
                validator = colorByOptions,
                **kwargs
            )
        if passed_sizeByOptions is not None:
            CustomKeyValidator(
                data = passed_sizeByOptions,
                log = self.log,
                prepend_path = [&#34;sizeByOptions&#34;],
                validator = sizeByOptions,
                **kwargs
            )
        for by in [&#34;colorBy&#34;, &#34;sizeBy&#34;]:
            by_value = self.data.get(by)
            if by_value is not None:
                available_options = list(self.data.get(f&#34;{by}Options&#34;, {}).keys())
                if by_value not in available_options:
                    self.__error__(
                        msg=f&#34;Invalid `{by}` ({by_value}) must be one of {available_options}&#34;
                    )
        # TODO: Validate Icons</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cave_utils.api.utils.ApiValidator" href="utils.html#cave_utils.api.utils.ApiValidator">ApiValidator</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cave_utils.api.maps.maps_data_star_legendGroups_star_data_star.spec"><code class="name flex">
<span>def <span class="ident">spec</span></span>(<span>value: bool, sizeBy: [<class 'str'>, None] = None, colorBy: [<class 'str'>, None] = None, lineBy: [<class 'str'>, None] = None, allowGrouping: bool = False, group: [<class 'bool'>, None] = None, groupCalcBySize: [<class 'str'>, None] = None, groupCalcByColor: [<class 'str'>, None] = None, groupScaleWithZoom: bool = False, groupScale: [<class 'int'>, <class 'float'>, None] = None, colorByOptions: [<class 'dict'>, None] = None, sizeByOptions: [<class 'dict'>, None] = None, icon: [<class 'str'>, None] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Required Arguments:</p>
<ul>
<li><code>value</code>:<ul>
<li>Type: bool</li>
<li>What: Whether or not to show this data layer on the map.</li>
</ul>
</li>
</ul>
<p>Optional Arguments:</p>
<ul>
<li><code>sizeBy</code>:<ul>
<li>Type: str | None</li>
<li>What: The prop to use for sizing the data layer.</li>
<li>Default: <code>None</code></li>
<li>Note: If <code>None</code>, the data layer will not be sized.</li>
<li>Note: Does not apply to shape layers.</li>
</ul>
</li>
<li><code>colorBy</code>:<ul>
<li>Type: str | None</li>
<li>What: The prop to use for coloring the data layer.</li>
<li>Default: <code>None</code></li>
<li>Note: If <code>None</code>, the data layer will not be colored.</li>
</ul>
</li>
<li><code>lineBy</code>:<ul>
<li>Type: str | None</li>
<li>What: The type of line to use for the data layer.</li>
<li>Accepted Values: <code>solid</code>, <code>dashed</code>, <code>dotted</code></li>
<li>Default: <code>solid</code></li>
<li>Note: Only applies to arc layers</li>
</ul>
</li>
<li><code>allowGrouping</code>:<ul>
<li>Type: bool</li>
<li>What: Whether or not to allow grouping of the data layer.</li>
<li>Default: <code>False</code></li>
<li>Note: Only applies to node layers.</li>
</ul>
</li>
<li><code>group</code>:<ul>
<li>Type: bool | None</li>
<li>What: Whether or not to group the data layer.</li>
<li>TODO: Validate default value</li>
<li>Default: <code>False</code></li>
<li>Note: If <code>None</code>, the data layer will not be grouped.</li>
<li>Note: Only applies to node layers.</li>
</ul>
</li>
<li><code>groupCalcBySize</code>:<ul>
<li>Type: str | None</li>
<li>What: The prop to use for calculating the size of the group.</li>
<li>Default: <code>sum</code></li>
<li>Accepted Values: [<code>sum</code>, <code>mean</code>, <code>median</code>, <code>mode</code>, <code>min</code>, <code>max</code>, <code>count</code>, <code>and</code>, <code>or</code>]</li>
<li>Note: If <code>None</code>, the data layer will not be grouped.</li>
<li>Note: Only applies to node layers.</li>
</ul>
</li>
<li><code>groupCalcByColor</code>:<ul>
<li>Type: str | None</li>
<li>What: The prop to use for calculating the color of the group.</li>
<li>TODO: Validate default value</li>
<li>Default: <code>sum</code></li>
<li>Accepted Values: [<code>sum</code>, <code>mean</code>, <code>median</code>, <code>mode</code>, <code>min</code>, <code>max</code>, <code>count</code>, <code>and</code>, <code>or</code>]</li>
<li>Note: If <code>None</code>, the data layer will not be grouped.</li>
<li>Note: Only applies to node layers.</li>
</ul>
</li>
<li><code>groupScaleWithZoom</code>:<ul>
<li>Type: bool</li>
<li>What: Whether or not to scale the group size with zoom.</li>
<li>Default: <code>False</code></li>
<li>Note: Only applies to node layers.</li>
<li>Note: If <code>False</code>, the group size will be constant as set by <code>groupScale</code>.</li>
</ul>
</li>
<li><code>groupScale</code>:<ul>
<li>Type: float | int | None</li>
<li>What: The zoom level at which to conduct grouping of the nodes.</li>
<li>Default: <code>None</code></li>
<li>Note: Only applies to node layers.</li>
<li>Note: If <code>None</code>, the group scale willl be determined by the map zoom.</li>
</ul>
</li>
<li><code><a title="cave_utils.api.maps.colorByOptions" href="#cave_utils.api.maps.colorByOptions">colorByOptions</a></code>:<ul>
<li>Type: dict | None</li>
<li>What: The options for coloring the data layer.</li>
<li>Default: <code>None</code></li>
<li>Note: If <code>None</code>, the data layer will not be colored.</li>
<li>Note: Does not apply to shape layers.</li>
<li>TODO: Add numeric and categorical example here.</li>
<li>See: <code><a title="cave_utils.api.maps.colorByOptions" href="#cave_utils.api.maps.colorByOptions">colorByOptions</a></code></li>
</ul>
</li>
<li><code><a title="cave_utils.api.maps.sizeByOptions" href="#cave_utils.api.maps.sizeByOptions">sizeByOptions</a></code>:<ul>
<li>Type: dict | None</li>
<li>What: The options for sizing the data layer.</li>
<li>Default: <code>None</code></li>
<li>Note: If <code>None</code>, the data layer will not be sized.</li>
<li>Note: Does not apply to shape layers.</li>
<li>TODO: Add numeric and categorical example here.</li>
<li>See: <code><a title="cave_utils.api.maps.sizeByOptions" href="#cave_utils.api.maps.sizeByOptions">sizeByOptions</a></code></li>
</ul>
</li>
<li><code>icon</code>:<ul>
<li>Type: str | None</li>
<li>What: The icon to use for the data layer.</li>
<li>Note: Only applies to node layers.</li>
<li>Note: Arc layer icons are determined by <code>lineBy</code>.</li>
<li>Note: Shape layer icons are always the default icon.</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spec(
    value: bool,
    sizeBy: [str, None] = None,
    colorBy: [str, None] = None,
    lineBy: [str, None] = None,
    allowGrouping: bool = False,
    group: [bool, None] = None,
    groupCalcBySize: [str, None] = None,
    groupCalcByColor: [str, None] = None,
    groupScaleWithZoom: bool = False,
    groupScale: [int, float, None] = None,
    colorByOptions: [dict, None] = None,
    sizeByOptions: [dict, None] = None,
    icon: [str, None] = None,
    **kwargs
):
    &#34;&#34;&#34;
    Required Arguments:

    - `value`:
        - Type: bool
        - What: Whether or not to show this data layer on the map.
    
    Optional Arguments:

    - `sizeBy`:
        - Type: str | None
        - What: The prop to use for sizing the data layer.
        - Default: `None`
        - Note: If `None`, the data layer will not be sized.
        - Note: Does not apply to shape layers.
    - `colorBy`:
        - Type: str | None
        - What: The prop to use for coloring the data layer.
        - Default: `None`
        - Note: If `None`, the data layer will not be colored.
    - `lineBy`:
        - Type: str | None
        - What: The type of line to use for the data layer.
        - Accepted Values: `solid`, `dashed`, `dotted`
        - Default: `solid`
        - Note: Only applies to arc layers
    - `allowGrouping`:
        - Type: bool
        - What: Whether or not to allow grouping of the data layer.
        - Default: `False`
        - Note: Only applies to node layers.
    - `group`:
        - Type: bool | None
        - What: Whether or not to group the data layer.
        - TODO: Validate default value
        - Default: `False`
        - Note: If `None`, the data layer will not be grouped.
        - Note: Only applies to node layers.
    - `groupCalcBySize`:
        - Type: str | None
        - What: The prop to use for calculating the size of the group.
        - Default: `sum`
        - Accepted Values: [`sum`, `mean`, `median`, `mode`, `min`, `max`, `count`, `and`, `or`]
        - Note: If `None`, the data layer will not be grouped.
        - Note: Only applies to node layers.
    - `groupCalcByColor`:
        - Type: str | None
        - What: The prop to use for calculating the color of the group.
        - TODO: Validate default value
        - Default: `sum`
        - Accepted Values: [`sum`, `mean`, `median`, `mode`, `min`, `max`, `count`, `and`, `or`]
        - Note: If `None`, the data layer will not be grouped.
        - Note: Only applies to node layers.
    - `groupScaleWithZoom`:
        - Type: bool
        - What: Whether or not to scale the group size with zoom.
        - Default: `False`
        - Note: Only applies to node layers.
        - Note: If `False`, the group size will be constant as set by `groupScale`.
    - `groupScale`:
        - Type: float | int | None
        - What: The zoom level at which to conduct grouping of the nodes.
        - Default: `None`
        - Note: Only applies to node layers.
        - Note: If `None`, the group scale willl be determined by the map zoom.
    - `colorByOptions`:
        - Type: dict | None
        - What: The options for coloring the data layer.
        - Default: `None`
        - Note: If `None`, the data layer will not be colored.
        - Note: Does not apply to shape layers.
        - TODO: Add numeric and categorical example here.
        - See: `cave_utils.api.maps.colorByOptions`
    - `sizeByOptions`:
        - Type: dict | None
        - What: The options for sizing the data layer.
        - Default: `None`
        - Note: If `None`, the data layer will not be sized.
        - Note: Does not apply to shape layers.
        - TODO: Add numeric and categorical example here.
        - See: `cave_utils.api.maps.sizeByOptions`
    - `icon`:
        - Type: str | None
        - What: The icon to use for the data layer.
        - Note: Only applies to node layers.
        - Note: Arc layer icons are determined by `lineBy`.
        - Note: Shape layer icons are always the default icon.
    &#34;&#34;&#34;
    return {&#34;kwargs&#34;: kwargs, &#34;accepted_values&#34;: {
        # TODO: Validate these are correct accepted values
        &#39;lineBy&#39;: [&#34;solid&#34;, &#34;dashed&#34;, &#34;dotted&#34;],
        &#39;groupCalcBySize&#39;: [&#34;sum&#34;, &#34;mean&#34;, &#34;median&#34;, &#34;mode&#34;, &#34;min&#34;, &#34;max&#34;, &#39;count&#39;, &#39;and&#39;, &#39;or&#39;],
        &#39;groupCalcByColor&#39;: [&#34;sum&#34;, &#34;mean&#34;, &#34;median&#34;, &#34;mode&#34;, &#34;min&#34;, &#34;max&#34;, &#39;count&#39;, &#39;and&#39;, &#39;or&#39;],
    }}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cave_utils.api.maps.sizeByOptions"><code class="flex name class">
<span>class <span class="ident">sizeByOptions</span></span>
<span>(</span><span>**fields)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@type_enforced.Enforcer
class sizeByOptions(ApiValidator):
    @staticmethod
    def spec(
        startSize: [str, None] = None,
        endSize: [str, None] = None,
        min: [float, int, None] = None,
        max: [float, int, None] = None,
        nullSize: [str, None] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Required Arguments:

        - `startSize`:
            - Type: str
            - What: The starting size for the gradient.
            - Accepted Values:
                - Any valid pixel string.
            - Eg: `&#34;10px&#34;`
            - Note: This is only required for numeric props.
        - `endSize`:
            - Type: str
            - What: The ending size for the gradient.
            - Accepted Values:
                - Any valid pixel string.
            - Eg: `&#34;10px&#34;`
            - Note: This is only required for numeric props.
        - `customKey`:
            - Type: str
            - What: A pixel size (pixel String) assigned to a categorical value.
                - Note: You should provide one `customKey` per option key in the associated prop.
            - Note: This is only required for non numeric props.
            - TODO: Flesh this out better

        Optional Arguments:

        - `min`:
            - Type: float | int | None
            - What: The minimum value for calculating the size.
            - Default: `None`
            - Note: If None, the min of the relevant data will be used.
        - `max`:
            - Type: float | int | None
            - What: The maximum value for calculating the size.
            - Default: `None`
            - Note: If None, the max of the relevant data will be used.
        - `nullSize`:
            - Type: str | None
            - What: The size to use for null values.
            - Default: `None`
            - Note: If None, null values will not be shown

        &#34;&#34;&#34;
        if startSize is not None or endSize is not None:
            if startSize is None:
                raise Exception(&#34;Must provide a `startSize` if `endSize` is provided&#34;)
            if endSize is None:
                raise Exception(&#34;Must provide a `endSize` if `startSize` is provided&#34;)
            return {
                &#34;kwargs&#34;: kwargs,
                &#34;accepted_values&#34;: {},
            }
        else:
            return {
                &#34;kwargs&#34;: {},
                &#34;accepted_values&#34;: {},
            }

    def __extend_spec__(self, **kwargs):
        for field in [&#34;startSize&#34;, &#34;endSize&#34;, &#34;nullSize&#34;]:
            field_value = self.data.get(field)
            if field_value is not None:
                self.__check_pixel_string_valid__(pixel_string=field_value, prepend_path=[field])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cave_utils.api.utils.ApiValidator" href="utils.html#cave_utils.api.utils.ApiValidator">ApiValidator</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cave_utils.api.maps.sizeByOptions.spec"><code class="name flex">
<span>def <span class="ident">spec</span></span>(<span>startSize: [<class 'str'>, None] = None, endSize: [<class 'str'>, None] = None, min: [<class 'float'>, <class 'int'>, None] = None, max: [<class 'float'>, <class 'int'>, None] = None, nullSize: [<class 'str'>, None] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Required Arguments:</p>
<ul>
<li><code>startSize</code>:<ul>
<li>Type: str</li>
<li>What: The starting size for the gradient.</li>
<li>Accepted Values:<ul>
<li>Any valid pixel string.</li>
</ul>
</li>
<li>Eg: <code>"10px"</code></li>
<li>Note: This is only required for numeric props.</li>
</ul>
</li>
<li><code>endSize</code>:<ul>
<li>Type: str</li>
<li>What: The ending size for the gradient.</li>
<li>Accepted Values:<ul>
<li>Any valid pixel string.</li>
</ul>
</li>
<li>Eg: <code>"10px"</code></li>
<li>Note: This is only required for numeric props.</li>
</ul>
</li>
<li><code>customKey</code>:<ul>
<li>Type: str</li>
<li>What: A pixel size (pixel String) assigned to a categorical value.<ul>
<li>Note: You should provide one <code>customKey</code> per option key in the associated prop.</li>
</ul>
</li>
<li>Note: This is only required for non numeric props.</li>
<li>TODO: Flesh this out better</li>
</ul>
</li>
</ul>
<p>Optional Arguments:</p>
<ul>
<li><code>min</code>:<ul>
<li>Type: float | int | None</li>
<li>What: The minimum value for calculating the size.</li>
<li>Default: <code>None</code></li>
<li>Note: If None, the min of the relevant data will be used.</li>
</ul>
</li>
<li><code>max</code>:<ul>
<li>Type: float | int | None</li>
<li>What: The maximum value for calculating the size.</li>
<li>Default: <code>None</code></li>
<li>Note: If None, the max of the relevant data will be used.</li>
</ul>
</li>
<li><code>nullSize</code>:<ul>
<li>Type: str | None</li>
<li>What: The size to use for null values.</li>
<li>Default: <code>None</code></li>
<li>Note: If None, null values will not be shown</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spec(
    startSize: [str, None] = None,
    endSize: [str, None] = None,
    min: [float, int, None] = None,
    max: [float, int, None] = None,
    nullSize: [str, None] = None,
    **kwargs,
):
    &#34;&#34;&#34;
    Required Arguments:

    - `startSize`:
        - Type: str
        - What: The starting size for the gradient.
        - Accepted Values:
            - Any valid pixel string.
        - Eg: `&#34;10px&#34;`
        - Note: This is only required for numeric props.
    - `endSize`:
        - Type: str
        - What: The ending size for the gradient.
        - Accepted Values:
            - Any valid pixel string.
        - Eg: `&#34;10px&#34;`
        - Note: This is only required for numeric props.
    - `customKey`:
        - Type: str
        - What: A pixel size (pixel String) assigned to a categorical value.
            - Note: You should provide one `customKey` per option key in the associated prop.
        - Note: This is only required for non numeric props.
        - TODO: Flesh this out better

    Optional Arguments:

    - `min`:
        - Type: float | int | None
        - What: The minimum value for calculating the size.
        - Default: `None`
        - Note: If None, the min of the relevant data will be used.
    - `max`:
        - Type: float | int | None
        - What: The maximum value for calculating the size.
        - Default: `None`
        - Note: If None, the max of the relevant data will be used.
    - `nullSize`:
        - Type: str | None
        - What: The size to use for null values.
        - Default: `None`
        - Note: If None, null values will not be shown

    &#34;&#34;&#34;
    if startSize is not None or endSize is not None:
        if startSize is None:
            raise Exception(&#34;Must provide a `startSize` if `endSize` is provided&#34;)
        if endSize is None:
            raise Exception(&#34;Must provide a `endSize` if `startSize` is provided&#34;)
        return {
            &#34;kwargs&#34;: kwargs,
            &#34;accepted_values&#34;: {},
        }
    else:
        return {
            &#34;kwargs&#34;: {},
            &#34;accepted_values&#34;: {},
        }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cave_utils.api.maps.viewport"><code class="flex name class">
<span>class <span class="ident">viewport</span></span>
<span>(</span><span>**fields)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api-path-mapsdatadefaultviewport">Api Path: maps.data.*.defaultViewport</h2>
<h2 id="api-path-mapsdataoptionalviewports">Api Path: maps.data.*.optionalViewports.*</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@type_enforced.Enforcer
class viewport(ApiValidator):
    &#34;&#34;&#34;
    ## Api Path: maps.data.\*.defaultViewport
    ## Api Path: maps.data.\*.optionalViewports.\*
    &#34;&#34;&#34;
    @staticmethod
    def spec(latitude: [int, float], longitude: [int, float], zoom: [int, float], bearing: [int, float, None] = None, pitch: [int, float, None] = None, maxZoom: [int, float, None] = None, minZoom: [int, float, None] = None, icon: [str, None] = None, name: [str, None] = None, **kwargs):
        &#34;&#34;&#34;
        Required Arguments:

        - `latitude`:
            - Type: float | int
            - What: The latitude of the viewport.
            - Note: Between -90 and 90.
        - `longitude`:
            - Type: float | int
            - What: The longitude of the viewport.
            - Note: Between -180 and 180.
        - `zoom`:
            - Type: float | int
            - What: The zoom of the viewport.
            - Note: Between 0 and 22.
        - `bearing`:
            - Type: float | int | None
            - What: The bearing of the viewport.
            - Default: `None`
            - Note: Between 0 and 360.
        - `pitch`:
            - Type: float | int | None
            - What: The pitch of the viewport.
            - Default: `None`
            - Note: Between 0 and 60.
        - `maxZoom`:
            - Type: float | int | None
            - What: The maximum zoom of the viewport.
            - Default: `None`
            - Note: Between 0 and 22.
        - `minZoom`:
            - Type: float | int | None
            - What: The minimum zoom of the viewport.
            - Default: `None`
            - Note: Between 0 and 22.
        - `icon`:
            - Type: str | None
            - What: The icon to use for the viewport.
            - Default: `None`
            - Note: If `None`, the default icon will be used.
            - TODO: Check this
        - `name`:
            - Type: str | None
            - What: The name of the viewport.
            - Note: Only used for optional viewports.

        &#34;&#34;&#34;
        return {
            &#34;kwargs&#34;: kwargs,
            &#34;accepted_values&#34;: {},
        }

    def __extend_spec__(self, **kwargs):
        field_validation = {
            &#34;latitude&#34;: (-90, 90),
            &#34;longitude&#34;: (-180, 180),
            &#34;zoom&#34;: (0, 22),
            &#34;bearing&#34;: (0, 360),
            &#34;pitch&#34;: (0, 60),
            &#34;maxZoom&#34;: (0, 22),
            &#34;minZoom&#34;: (0, 22),
        }
        if kwargs.get(&#39;is_optional_viewport&#39;):
            if self.data.get(&#34;name&#34;) is None:
                self.__error__(
                    msg=&#34;`name` must be specified for optional viewports&#34;
                )
            if self.data.get(&#34;icon&#34;) is None:
                self.__error__(
                    msg=&#34;`icon` must be specified for optional viewports&#34;
                )
        for field in [&#34;latitude&#34;, &#34;longitude&#34;, &#34;zoom&#34;, &#34;bearing&#34;, &#34;pitch&#34;, &#34;maxZoom&#34;, &#34;minZoom&#34;]:
            value = self.data.get(field)
            if value is not None:
                if not isinstance(value, (int, float)):
                    continue
                if value &lt; field_validation[field][0] or value &gt; field_validation[field][1]:
                    self.__error__(
                        msg=f&#34;`{field} = {value}` but it should be between {field_validation[field][0]} and {field_validation[field][1]}&#34;
                    )
                    continue
        # TODO: Validate Icons
        # if self.data.get(&#34;icon&#34;) is not None:
        #     self.__check_url_valid__(url=self.data.get(&#34;icon&#34;), prepend_path=[&#34;icon&#34;])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cave_utils.api.utils.ApiValidator" href="utils.html#cave_utils.api.utils.ApiValidator">ApiValidator</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cave_utils.api.maps.viewport.spec"><code class="name flex">
<span>def <span class="ident">spec</span></span>(<span>latitude: [<class 'int'>, <class 'float'>], longitude: [<class 'int'>, <class 'float'>], zoom: [<class 'int'>, <class 'float'>], bearing: [<class 'int'>, <class 'float'>, None] = None, pitch: [<class 'int'>, <class 'float'>, None] = None, maxZoom: [<class 'int'>, <class 'float'>, None] = None, minZoom: [<class 'int'>, <class 'float'>, None] = None, icon: [<class 'str'>, None] = None, name: [<class 'str'>, None] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Required Arguments:</p>
<ul>
<li><code>latitude</code>:<ul>
<li>Type: float | int</li>
<li>What: The latitude of the viewport.</li>
<li>Note: Between -90 and 90.</li>
</ul>
</li>
<li><code>longitude</code>:<ul>
<li>Type: float | int</li>
<li>What: The longitude of the viewport.</li>
<li>Note: Between -180 and 180.</li>
</ul>
</li>
<li><code>zoom</code>:<ul>
<li>Type: float | int</li>
<li>What: The zoom of the viewport.</li>
<li>Note: Between 0 and 22.</li>
</ul>
</li>
<li><code>bearing</code>:<ul>
<li>Type: float | int | None</li>
<li>What: The bearing of the viewport.</li>
<li>Default: <code>None</code></li>
<li>Note: Between 0 and 360.</li>
</ul>
</li>
<li><code>pitch</code>:<ul>
<li>Type: float | int | None</li>
<li>What: The pitch of the viewport.</li>
<li>Default: <code>None</code></li>
<li>Note: Between 0 and 60.</li>
</ul>
</li>
<li><code>maxZoom</code>:<ul>
<li>Type: float | int | None</li>
<li>What: The maximum zoom of the viewport.</li>
<li>Default: <code>None</code></li>
<li>Note: Between 0 and 22.</li>
</ul>
</li>
<li><code>minZoom</code>:<ul>
<li>Type: float | int | None</li>
<li>What: The minimum zoom of the viewport.</li>
<li>Default: <code>None</code></li>
<li>Note: Between 0 and 22.</li>
</ul>
</li>
<li><code>icon</code>:<ul>
<li>Type: str | None</li>
<li>What: The icon to use for the viewport.</li>
<li>Default: <code>None</code></li>
<li>Note: If <code>None</code>, the default icon will be used.</li>
<li>TODO: Check this</li>
</ul>
</li>
<li><code>name</code>:<ul>
<li>Type: str | None</li>
<li>What: The name of the viewport.</li>
<li>Note: Only used for optional viewports.</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spec(latitude: [int, float], longitude: [int, float], zoom: [int, float], bearing: [int, float, None] = None, pitch: [int, float, None] = None, maxZoom: [int, float, None] = None, minZoom: [int, float, None] = None, icon: [str, None] = None, name: [str, None] = None, **kwargs):
    &#34;&#34;&#34;
    Required Arguments:

    - `latitude`:
        - Type: float | int
        - What: The latitude of the viewport.
        - Note: Between -90 and 90.
    - `longitude`:
        - Type: float | int
        - What: The longitude of the viewport.
        - Note: Between -180 and 180.
    - `zoom`:
        - Type: float | int
        - What: The zoom of the viewport.
        - Note: Between 0 and 22.
    - `bearing`:
        - Type: float | int | None
        - What: The bearing of the viewport.
        - Default: `None`
        - Note: Between 0 and 360.
    - `pitch`:
        - Type: float | int | None
        - What: The pitch of the viewport.
        - Default: `None`
        - Note: Between 0 and 60.
    - `maxZoom`:
        - Type: float | int | None
        - What: The maximum zoom of the viewport.
        - Default: `None`
        - Note: Between 0 and 22.
    - `minZoom`:
        - Type: float | int | None
        - What: The minimum zoom of the viewport.
        - Default: `None`
        - Note: Between 0 and 22.
    - `icon`:
        - Type: str | None
        - What: The icon to use for the viewport.
        - Default: `None`
        - Note: If `None`, the default icon will be used.
        - TODO: Check this
    - `name`:
        - Type: str | None
        - What: The name of the viewport.
        - Note: Only used for optional viewports.

    &#34;&#34;&#34;
    return {
        &#34;kwargs&#34;: kwargs,
        &#34;accepted_values&#34;: {},
    }</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cave_utils.api" href="index.html">cave_utils.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cave_utils.api.maps.colorByOptions" href="#cave_utils.api.maps.colorByOptions">colorByOptions</a></code></h4>
<ul class="">
<li><code><a title="cave_utils.api.maps.colorByOptions.spec" href="#cave_utils.api.maps.colorByOptions.spec">spec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cave_utils.api.maps.maps" href="#cave_utils.api.maps.maps">maps</a></code></h4>
<ul class="">
<li><code><a title="cave_utils.api.maps.maps.spec" href="#cave_utils.api.maps.maps.spec">spec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cave_utils.api.maps.maps_additionalMapStyles_star" href="#cave_utils.api.maps.maps_additionalMapStyles_star">maps_additionalMapStyles_star</a></code></h4>
<ul class="">
<li><code><a title="cave_utils.api.maps.maps_additionalMapStyles_star.spec" href="#cave_utils.api.maps.maps_additionalMapStyles_star.spec">spec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cave_utils.api.maps.maps_data_star" href="#cave_utils.api.maps.maps_data_star">maps_data_star</a></code></h4>
<ul class="">
<li><code><a title="cave_utils.api.maps.maps_data_star.spec" href="#cave_utils.api.maps.maps_data_star.spec">spec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cave_utils.api.maps.maps_data_star_legendGroups_star" href="#cave_utils.api.maps.maps_data_star_legendGroups_star">maps_data_star_legendGroups_star</a></code></h4>
<ul class="">
<li><code><a title="cave_utils.api.maps.maps_data_star_legendGroups_star.spec" href="#cave_utils.api.maps.maps_data_star_legendGroups_star.spec">spec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cave_utils.api.maps.maps_data_star_legendGroups_star_data_star" href="#cave_utils.api.maps.maps_data_star_legendGroups_star_data_star">maps_data_star_legendGroups_star_data_star</a></code></h4>
<ul class="">
<li><code><a title="cave_utils.api.maps.maps_data_star_legendGroups_star_data_star.spec" href="#cave_utils.api.maps.maps_data_star_legendGroups_star_data_star.spec">spec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cave_utils.api.maps.sizeByOptions" href="#cave_utils.api.maps.sizeByOptions">sizeByOptions</a></code></h4>
<ul class="">
<li><code><a title="cave_utils.api.maps.sizeByOptions.spec" href="#cave_utils.api.maps.sizeByOptions.spec">spec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cave_utils.api.maps.viewport" href="#cave_utils.api.maps.viewport">viewport</a></code></h4>
<ul class="">
<li><code><a title="cave_utils.api.maps.viewport.spec" href="#cave_utils.api.maps.viewport.spec">spec</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>